## Redis
### data-struct
#### SDS

每个`sds.h/sdshdr` 结构表示一个SDS值：

```c
strcut sdshdr {
    // 记录 buf 数组中已使用字节的数量
    // 等于 SDS 所保存字符串的长度
    int len;

    // 记录 buf 数组中未使用字节的数量
    int free;

    // 字节数组，用于保存字符串
    char buf[];
}
```

值得注意的是在存储中len中是不把\0算在内的，是自动添加的。

##### SDS 与 C 字符串的区别

* 常数复杂度获取字符串长度，可以直接通过一个len的值获取

* 杜绝缓冲区溢出  在修改内容的时候传统的C语言的字符串是存在溢出的可能的，但是在SDS中是存在一个len的值进行修改，在自带的API中sdcat中会自动检查拼写。
* 减少修改字符串时带来的内存重新分配次数   
  *  空间预分配 用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，不但会为SDS预先分配修改所必须要的空间，还会为SDS分配额外的未使用的空间 
    * 如果对 SDS 进行修改之后， SDS 的长度（也即是 `len` 属性的值）将小于 `1 MB` ， 那么程序分配和 `len` 属性同样大小的未使用空间， 这时 SDS `len` 属性的值将和 `free` 属性的值相同。 举个例子， 如果进行修改之后， SDS 的 `len` 将变成 `13` 字节， 那么程序也会分配 `13` 字节的未使用空间， SDS 的 `buf` 数组的实际长度将变成 `13 + 13 + 1 = 27` 字节（额外的一字节用于保存空字符）。
    * 如果对 SDS 进行修改之后， SDS 的长度将大于等于 `1 MB` ， 那么程序会分配 `1 MB` 的未使用空间。 举个例子， 如果进行修改之后， SDS 的 `len` 将变成 `30 MB` ， 那么程序会分配 `1 MB` 的未使用空间， SDS 的 `buf` 数组的实际长度将为 `30 MB + 1 MB + 1 byte` 。
  * 惰性空间释放 惰性空间释放用于优化SDS的字符串缩短操作：当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 `free` 属性将这些字节的数量记录起来， 并等待将来使用。
* 二进制安全 因为有了len这个值于是支持了SDS可以存储二进制的数据。
* 兼容部分C字符函数 可以使用部分c字符的库函数。

#### 链表

